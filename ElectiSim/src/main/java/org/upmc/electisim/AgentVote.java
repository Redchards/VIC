package org.upmc.electisim;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import org.upmc.electisim.utils.MapUtils;

/**
 * A class representing the vote of a single agent after applying the voting strategy.
 * @see org.upmc.electisim.IVotingStrategy
 * @see org.upmc.electisim.Agent
 */
public class AgentVote {
	/*
	 * (non-javadoc)
	 * The agent from which the vote has been emitted
	 */
	private Agent agent;
	
	/*
	 * (non-javadoc)
	 * The map of scores generated by the vote
	 */
	private Map<IElectable, Integer> scoreMap;
	
	
	/**
	 * Builds an agent's vote result from an agent. The map of scores will hence be empty
	 * @param agent the agent emitting this vote
	 */
	public AgentVote(Agent agent) {
		this(agent, new HashMap<IElectable, Integer>());
	}
	
	/**
	 * Builds an agent's vote result from an agent and a map of scores
	 * @param agent the agent emitting this vote
	 * @param scoreMap the map of scores to be used
	 */
	public AgentVote(Agent agent, Map<IElectable, Integer> scoreMap) {
		this.agent = agent;
		this.scoreMap = new HashMap<>(scoreMap);
	}
	
	/**
	 * Builds an agent's vote result from another vote result
	 * @param other the other vote result to copy
	 */
	public AgentVote(AgentVote other) {
		this(other.agent, other.scoreMap);
	}
	
	
	/**
	 * Sets the score of one candidate
	 * @param candidate the candidate for which to modify the vote
	 * @param score the score to use
	 */
	public void setScore(IElectable candidate, int score){
		scoreMap.put(candidate, score);
	}

	/**
	 * @return the agent which emitted this vote
	 */
	public Agent getAgent(){
		return agent;
	}
	
	/**
	 * @return the map of scores for this vote
	 */
	public Map<IElectable, Integer> getScoreMap(){
		return scoreMap;
	}
	
	/**
	 * Generates a linear order from the map of scores. Is used in many strategies
	 * and voting rules
	 * 
	 * @return a linear order on the electable entities in this vote
	 */
	public List<IElectable> getLinearOrder(){
		List<Entry<IElectable, Integer>> l = MapUtils.sortByValue(this.scoreMap);
		Collections.reverse(l);
		List<IElectable> res = new ArrayList<>();
		
		for(Entry<IElectable, Integer> e : l) {
			res.add(e.getKey());
		}
		
		return res;
	}
	
	/**
	 * @param k the number of best elements we want
	 * @return the k bests candidate in this vote
	 */
	public List<IElectable> getKBests(int k) {
		return this.getLinearOrder().subList(0, k);
	}
}
