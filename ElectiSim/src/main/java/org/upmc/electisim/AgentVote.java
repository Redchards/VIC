package org.upmc.electisim;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import org.upmc.electisim.utils.MapUtils;

/**
 * A class representing the vote of a single agent after applying the voting strategy.
 * 
 * @see org.upmc.electisim.IAgentStrategy
 * @see org.upmc.electisim.Agent
 */
public class AgentVote {
	/*
	 * (non-javadoc)
	 * The agent from which the vote has been emitted
	 */
	private Agent agent;
	
	/*
	 * (non-javadoc)
	 * The map of scores generated by the vote
	 */
	private Map<IElectable, Integer> scoreMap;
	
	
	/**
	 * Build an agent's vote result from an agent. The map of scores will hence be empty
	 * @param agent the agent emitting this vote
	 */
	public AgentVote(Agent agent) {
		this(agent, new HashMap<IElectable, Integer>());
	}
	
	/**
	 * Build an agent's vote result from an agent and a map of scores
	 * @param agent the agent emitting this vote
	 * @param scoreMap the map of scores to be used
	 */
	public AgentVote(Agent agent, Map<IElectable, Integer> scoreMap) {
		this.agent = agent;
		this.scoreMap = new HashMap<>(scoreMap);
	}
	
	/**
	 * Builds an agent's vote result from another vote result
	 * @param other the other vote result to copy
	 */
	public AgentVote(AgentVote other) {
		this(other.agent, other.scoreMap);
	}
	
	
	/**
	 * Set the score of one candidate
	 * @param candidate the candidate for which to modify the vote
	 * @param score the score to use
	 */
	public void setScore(IElectable candidate, int score){
		scoreMap.put(candidate, score);
	}

	/**
	 * @return the agent which emitted this vote
	 */
	public Agent getAgent(){
		return agent;
	}
	
	/**
	 * @return the map of scores for this vote
	 */
	public Map<IElectable, Integer> getScoreMap(){
		return scoreMap;
	}
	
	/**
	 * Generate a linear order from the map of scores. Is used in many strategies
	 * and voting rules
	 * 
	 * @return a linear order on the electable entities in this vote
	 */
	public List<IElectable> getLinearOrder(){
		List<Entry<IElectable, Integer>> l = MapUtils.sortByValue(this.scoreMap);
		Collections.reverse(l);
		List<IElectable> res = new ArrayList<>();
		
		for(Entry<IElectable, Integer> e : l) {
			res.add(e.getKey());
		}
		
		return res;
	}
	
	/**
	 * @param k the number of best elements we want
	 * @return the k bests candidate in this vote
	 */
	public List<IElectable> getKBests(int k) {
		return this.getLinearOrder().subList(0, k);
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((agent == null) ? 0 : agent.hashCode());
		result = prime * result + ((scoreMap == null) ? 0 : scoreMap.hashCode());
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		AgentVote other = (AgentVote) obj;
		if (agent == null) {
			if (other.agent != null)
				return false;
		} else if (!agent.equals(other.agent))
			return false;
		if (scoreMap == null) {
			if (other.scoreMap != null)
				return false;
		} else if (!scoreMap.equals(other.scoreMap))
			return false;
		return true;
	}
}
